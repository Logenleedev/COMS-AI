<!DOCTYPE HTML>
<html>
<head>
    <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Copy Detection Report</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-uWxY/CJNBR+1zjPWmfnSnVxwRheevXITnMqoEIeG1LJrdI0GlVs/9cVSyPYXdcSF" crossorigin="anonymous">
  <style>
    h1 {
      text-align: center;
    }
    .highlight-green {
      background-color: #b6f2b6;
    }
    .highlight-red {
      background-color: #f2b6b6;
    }
    pre {
      text-align: left;
    }
  </style>
</head>
<body>
<div class="container" style="margin-top: 3em; max-width: 1400px">
  <h1 style="margin-bottom: 1em;">Copy Detection Report</h1>
  <h2>Overview</h2>
    <div class="container d-flex justify-content-center">
      <div class="col">
        <h4 style="text-align: center;">Similarity Matrix</h4>
        <img src="data:image/png;base64, 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qamaMmWK9uzZc85jVq5cKYfDEVISEhK6qccAAADWi+kAcNOmTZozZ462bNmiDRs26NSpU5o4caJaWlrOeZzb7dahQ4eC5ZNPPummHgMAEDuMgGFqgXliegi4qqoqZHvlypVKTU1VbW2txo0b1+FxDodDHo/H6u4BAABEREwHgN/U2NgoSUpOTj5nvebmZl1xxRUKBAK65ppr9F//9V+66qqrwtZtbW1Va2vrWedoamauAs7Pl8apSHcBPUhTU1Oku4Ae5Mz3JVILKL40Wk2bu/el+K00k8OwybKaQCCgf/7nf9bx48e1efPmDuvV1NToo48+UnZ2thobG7V06VK98cYb2rVrly677LKz6i9atEj33XeflV0HAOCC7Nu3TwMHDuy28508eVIDBgyQ3+83tV2Px6P9+/czN98EtgkAZ8+erb/+9a/avHlz2ECuI6dOndKwYcM0ffp0LV68+KzPv5kBPH78uK644grV1dUpKSnJlL7HiqamJmVmZqq+vl5utzvS3Yka3JfwuC/hcV/C476E19jYqMsvv1yff/65+vbt263nPnnypNra2kxtMz4+nuDPJLYYAi4uLtbLL7+sN954o1PBnyRdfPHFGjVqlPbu3Rv2c5fLJZfLddb+pKQkfoQ64Ha7uTdhcF/C476Ex30Jj/sSntPZ/Ws+ExISCNaiWEyvAjYMQ8XFxXrxxRe1ceNGDRgwoNNttLe367333lN6eroFPQQAAOh+MZ0BnDNnjlavXq2XXnpJffr0Cc5FSEpKUq9evSRJM2bMUP/+/VVWViZJuv/++/Xd735XgwcP1vHjx/XQQw/pk08+0e233x6x6wAAADBTTAeAy5cvlyQVFBSE7H/iiSd06623SpLq6upCUuOff/65Zs2aJb/fr379+mn06NF66623NHz48PM6p8vlUmlpadhhYbvj3oTHfQmP+xIe9yU87kt43Bd0xDaLQAAAAHBaTM8BBAAAwNkIAAEAAGyGABAAAMBmCAABAABshgDQBJ999pluueUWud1u9e3bV7fddpuam5vPeUxBQYEcDkdI+fnPf95NPbZORUWFsrKylJCQoLy8PG3btu2c9Z977jkNHTpUCQkJGjFihNavX99NPe1enbkvK1euPOu7EWsPU33jjTd0ww03KCMjQw6HQ+vWrfvWY6qrq3XNNdfI5XJp8ODBWrlypeX9jITO3pvq6uqzvi8Oh8P0V3BFUllZma699lr16dNHqampmjJlivbs2fOtx8X670tX7osdfl9wfggATXDLLbdo165d2rBhQ/CNI3fccce3Hjdr1iwdOnQoWB588MFu6K111q5dq5KSEpWWlmr79u0aOXKkCgsLdfjw4bD133rrLU2fPl233XabduzYoSlTpmjKlCl6//33u7nn1ursfZFOv83g69+NTz75pBt7bL2WlhaNHDlSFRUV51V///79uv766/XDH/5QO3fu1Lx583T77bfr1Vdftbin3a+z9+aMPXv2hHxnUlNTLeph99u0aZPmzJmjLVu2aMOGDTp16pQmTpyolpaWDo+xw+9LV+6LFPu/LzhPBi7IBx98YEgy3n777eC+v/71r4bD4TAOHjzY4XHjx4835s6d2w097D5jxowx5syZE9xub283MjIyjLKysrD1//Vf/9W4/vrrQ/bl5eUZ//Ef/2FpP7tbZ+/LE088YSQlJXVT7yJPkvHiiy+es878+fONq666KmTf1KlTjcLCQgt7Fnnnc29ef/11Q5Lx+eefd0ufosHhw4cNScamTZs6rGOX35evO5/7YrffF3SMDOAFqqmpUd++fZWbmxvc5/V65XQ6tXXr1nMe+8wzzyglJUVXX321FixYoBMnTljdXcu0tbWptrZWXq83uM/pdMrr9aqmpibsMTU1NSH1JamwsLDD+j1RV+6LJDU3N+uKK65QZmambrzxRu3atas7uhu17PBduVA5OTlKT0/XddddpzfffDPS3bFUY2OjJCk5ObnDOnb8zpzPfZH4fcFpBIAXyO/3nzXUctFFFyk5Ofmcc3B++tOf6umnn9brr7+uBQsWaNWqVfq3f/s3q7trmaNHj6q9vV1paWkh+9PS0jq8D36/v1P1e6Ku3JchQ4ZoxYoVeumll/T0008rEAho7NixOnDgQHd0OSp19F1pamrS3//+9wj1Kjqkp6ersrJSzz//vJ5//nllZmaqoKBA27dvj3TXLBEIBDRv3jx973vf09VXX91hPTv8vnzd+d4Xfl9wRky/Cu5C3H333VqyZMk56+zevbvL7X99juCIESOUnp6uCRMmaN++fRo0aFCX20XPl5+fr/z8/OD22LFjNWzYMD366KNavHhxBHuGaDRkyBANGTIkuD127Fjt27dPjzzyiFatWhXBnlljzpw5ev/997V58+ZIdyWqnO994fcFZxAAduAXv/hF8H3BHRk4cKA8Hs9Zk/m//PJLffbZZ/J4POd9vry8PEnS3r17e2QAmJKSori4ODU0NITsb2ho6PA+eDyeTtXvibpyX77p4osv1qhRo7R3714rutgjdPRdcbvd6tWrV4R6Fb3GjBkTkwFScXFxcKHdZZddds66dvh9OaMz9+Wb+H2xL4aAO3DppZdq6NCh5yzx8fHKz8/X8ePHVVtbGzx248aNCgQCwaDufOzcuVPS6eGcnig+Pl6jR4+Wz+cL7gsEAvL5fCH/2/y6/Pz8kPqStGHDhg7r90RduS/f1N7ervfee6/HfjfMYIfvipl27twZU98XwzBUXFysF198URs3btSAAQO+9Rg7fGe6cl++id8XG4v0KpRYMGnSJGPUqFHG1q1bjc2bNxtXXnmlMX369ODnBw4cMIYMGWJs3brVMAzD2Lt3r3H//fcb77zzjrF//37jpZdeMgYOHGiMGzcuUpdgijVr1hgul8tYuXKl8cEHHxh33HGH0bdvX8Pv9xuGYRg/+9nPjLvvvjtY/8033zQuuugiY+nSpcbu3buN0tJS4+KLLzbee++9SF2CJTp7X+677z7j1VdfNfbt22fU1tYa06ZNMxISEoxdu3ZF6hJM98UXXxg7duwwduzYYUgyli1bZuzYscP45JNPDMMwjLvvvtv42c9+Fqz/f//3f0ZiYqJx1113Gbt37zYqKiqMuLg4o6qqKlKXYJnO3ptHHnnEWLdunfHRRx8Z7733njF37lzD6XQar732WqQuwXSzZ882kpKSjOrqauPQoUPBcuLEiWAdO/6+dOW+2OH3BeeHANAEx44dM6ZPn2707t3bcLvdRlFRkfHFF18EP9+/f78hyXj99dcNwzCMuro6Y9y4cUZycrLhcrmMwYMHG3fddZfR2NgYoSswzx/+8Afj8ssvN+Lj440xY8YYW7ZsCX42fvx4Y+bMmSH1n332WeM73/mOER8fb1x11VXGK6+80s097h6duS/z5s0L1k1LSzN+9KMfGdu3b49Ar61z5tEl3yxn7sPMmTON8ePHn3VMTk6OER8fbwwcONB44oknur3f3aGz92bJkiXGoEGDjISEBCM5OdkoKCgwNm7cGJnOWyTc/ZAU8h2w4+9LV+6LHX5fcH4chmEY3ZZuBAAAQMQxBxAAAMBmCAABAABshgAQAADAZggAAQAAbIYAEAAAwGYIAAEAAGyGABAAAMBmCAABAABshgAQAADAZggAAQAAbIYAEAAAwGYIAAEAAGyGABAAAMBmCAABAABshgAQAADAZggAAQAAbIYAEAAAwGb+H18flGe1I2+DAAAAAElFTkSuQmCC" alt="Code similarity matrix">
      </div>
      <div class="col">
        <h4 style="text-align: center;">Similarity Score Distribution</h4>
        <img src="data:image/png;base64, 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" alt="Code similarity histogram">
      </div>
    </div>
    <p style="text-align: center">
      <i>Note: a score of -1 in the similarity matrix indicates the comparison was skipped</i>
    </p>
    <p>
    Number of files tested: 3<br>
    Number of reference files: 3<br>
    Test files above display threshold: 2 (66.67%)<br><br>
    </p>

  <h2>Matched Code</h2>
  <table class="table table-striped table-sm">
  <tbody class="table-light">
  
  <tr>
  <td style="text-align: center;">
  <p>
    Test file: <i>hw2/reference/driver_3.py</i> (<b>36.77%</b>)<br>
    Reference file: <i>hw2/puzzle.py</i> (<b>38.90%</b>)<br>
    Token overlap: 613<br><br>
    <button class="btn btn-secondary" type="button" data-bs-toggle="collapse" data-bs-target="#collapse-1" aria-expanded="false" aria-controls="collapse-1">
      View matched code
    </button>
  </p>
  <div class="collapse" id="collapse-1">
    <div class="card card-body">
      <div class="row">
        <div class="col" style="max-width: 600px">
          <pre><code># -*- coding: utf-8 -*-

import sys
import copy
import itertools
import queue
    
def createSudokuCsp():
    global sudokuConstraint
    
    #Create domain values
    domain = [1,2,3,4,5,6,7,8,9]
    #Create sudoku board containing all the variables
    <span class='highlight-red'>sudokuBoard = [[&#39;A1&#39;, &#39;A2&#39;, &#39;A3&#39;, &#39;A4&#39;, &#39;A5&#39;, &#39;A6&#39;, &#39;A7&#39;, &#39;A8&#39;, &#39;A9&#39;],
                   [&#39;B1&#39;, &#39;B2&#39;, &#39;B3&#39;, &#39;B4&#39;, &#39;B5&#39;, &#39;B6&#39;</span>, &#39;B7&#39;, &#39;B8&#39;, &#39;B9&#39;],
                   [&#39;C1&#39;, &#39;C2&#39;, &#39;C3&#39;, &#39;C4&#39;, &#39;C5&#39;, &#39;C6&#39;, &#39;C7&#39;, &#39;C8&#39;, &#39;C9&#39;],
                   [&#39;D1&#39;, &#39;D2&#39;, &#39;D3&#39;, &#39;D4&#39;, &#39;D5&#39;, &#39;D6&#39;, &#39;D7&#39;, &#39;D8&#39;, &#39;D9&#39;],
                   [&#39;E1&#39;, &#39;E2&#39;, &#39;E3&#39;, &#39;E4&#39;, &#39;E5&#39;, &#39;E6&#39;, &#39;E7&#39;, &#39;E8&#39;, &#39;E9&#39;],
                   [&#39;F1&#39;, &#39;F2&#39;, &#39;F3&#39;, &#39;F4&#39;, &#39;F5&#39;, &#39;F6&#39;, &#39;F7&#39;, &#39;F8&#39;, &#39;F9&#39;],
                   [&#39;G1&#39;, &#39;G2&#39;, &#39;G3&#39;, &#39;G4&#39;, &#39;G5&#39;, &#39;G6&#39;, &#39;G7&#39;, &#39;G8&#39;, &#39;G9&#39;],
                   [&#39;H1&#39;, &#39;H2&#39;, &#39;H3&#39;, &#39;H4&#39;, &#39;H5&#39;, &#39;H6&#39;, &#39;H7&#39;, &#39;H8&#39;, &#39;H9&#39;],
                   [&#39;I1&#39;, &#39;I2&#39;, &#39;I3&#39;, <span class='highlight-red'>&#39;I4&#39;, &#39;I5&#39;, &#39;I6&#39;, &#39;I7&#39;, &#39;I8&#39;, &#39;I9&#39;]]
    #Assign domain values for each variable
    sudokuDomain = {</span>key:list(domain) for row in sudokuBoard for key in row}
    #Create a copy of sudoku dictionary to store value assignment for each variable   
    sudokuAssign = {key:0 for key in sudokuDomain}

    #Create constraints
    constraintList = []
    #Constraints along row
    for row in sudokuBoard:       
        constraintList = constraintList + list(itertools.<span class='highlight-red'>permutations(row,2))
    #Constraints along column
    sudokuBoardT = list(map(list,zip(*sudokuBoard))) #Transpose the sudoku board 
    
    for col in sudokuBoardT:       
        constraintList </span>= constraintList + list(itertools.<span class='highlight-red'>permutations(col,2))
    #Constraints within each 3x3 square
    for row in [0,3,6]:
        for col in [0,3,6]:
            box = [</span>val for row in sudokuBoard[row:row+3] for val in row[col:col+3]]    
            constraintList = constraintList + list(itertools.permutations(box,2))
    #Remove duplicate constraints
    constraintList = list(set(constraintList))
    #Create a dictionary to store constraints. Initialize constraints to empty lists.
    sudokuConstraint = {key:list([]) for key in sudokuDomain} 
    #Associate the constraints with their respective keys in a dictionary
    for val in constraintList:
        sudokuConstraint[val[0]<span class='highlight-red'>].append(val)



    return sudokuAssign, sudokuDomain, constraintList

def selectUnassignedVariable(sudokuAssign,sudokuDomain</span>):
    #Minimum remaining values heuristic is used
    MRV = 100 #A randomly chosen number larger than domain size
    for row in &#39;ABCDEFGHI&#39;:
        for col in &#39;123456789&#39;:
            if sudokuAssign[row+col] == 0: #Consider only unassigned variables
                value = sudokuDomain[row+col]
                if len(value) &lt; MRV:
                    MRV = len(value)
                    chosenKey = row+col 
    return <span class='highlight-red'>chosenKey 

def consistent(sudokuAssign, sudokuDomain, chosenKey, value):
    global sudokuConstraint
    
    constraintList = sudokuConstraint[chosenKey]
    for constraint </span>in constraintList:
        if value == sudokuAssign[constraint[1]]<span class='highlight-red'>:
            return False 
    return True

def inference(sudokuAssign, sudokuDomain, chosenKey, value):
    #This inference function implements forward checking

    global sudokuConstraint
    
    constraintList = sudokuConstraint</span>[chosenKey]
    for constraint in constraintList:
        checkKey = constraint[1]
        <span class='highlight-red'>if sudokuAssign[checkKey] == 0: #Perform forward checking only on unassigned variables
            if value in sudokuDomain[checkKey]:
                sudokuDomain[checkKey].remove(value)
            </span>if not sudokuDomain[checkKey<span class='highlight-red'>]: #If domain is empty, i.e., no legal values remaining 
                return (False, sudokuAssign, sudokuDomain)
    return (True, sudokuAssign, sudokuDomain)
    
def backtracksearch(sudokuAssign,sudokuDomain):  
    #Check if assignment is complete
    </span>if all(value&gt;0 for key,value in sudokuAssign.items()):
        return (True, sudokuAssign, sudokuDomain)
    chosenKey = selectUnassignedVariable(sudokuAssign, sudokuDomain)
    # print(chosenKey)
    <span class='highlight-red'>for value in sudokuDomain[chosenKey]:
        if consistent(sudokuAssign, sudokuDomain, chosenKey, value):
            sudokuAssignNew = copy</span>.deepcopy(sudokuAssign)
            sudokuDomainNew = copy.deepcopy(sudokuDomain)
            sudokuAssignNew[chosenKey] = value
            sudokuDomainNew[chosenKey] = [value]
            resultInference = inference(sudokuAssignNew, sudokuDomainNew, chosenKey, value)
            if resultInference[0] == True:
                resultBTS = backtracksearch(resultInference[1],resultInference[2]<span class='highlight-red'>)
                if resultBTS[0] == True:
                    return resultBTS
    return (False, sudokuAssign, sudokuDomain)

def makeAssign(sudokuAssign</span>, sudokuDomain):
    <span class='highlight-red'>for key,value in sudokuDomain.items():
        if len(value) == 1:
            sudokuAssign[key] = value[0]
    return </span>sudokuAssign    

def getNeighbours(Xi):
    global sudokuConstraint
    neighbours = [Xk for Xi, Xk in sudokuConstraint[Xi]]
    return neighbours
    
def revise(sudokuDomain, Xi, Xj):
    <span class='highlight-red'>revised = False
    for x in sudokuDomain[Xi]:
        if not any(y!=x for y in sudokuDomain[Xj]):
            sudokuDomain[Xi].remove(x)
            revised = True
    </span>return revised

def AC3(sudokuAssign,sudokuDomain, constraintList):  
    q = queue.<span class='highlight-red'>Queue()
    for constraint in constraintList:
        q.put(constraint)
    while not q.empty():
        Xi</span>,Xj = q.get()
        if revise(sudokuDomain, Xi, Xj):
            if not sudokuDomain[Xi]:
                return (False, sudokuAssign, sudokuDomain)
            for Xk in getNeighbours(Xi):
                q.put((Xk,Xi))
    sudokuAssign = makeAssign(sudokuAssign, sudokuDomain)
    return (True, sudokuAssign, sudokuDomain)

def visualizeBoard(sudokuAssign):
    #Prints a sudoku grid containing the assigned variables.
    #This function accepts a dictionary of the form:
    #sudokuAssign = {&#39;A1&#39;:1, &#39;A2&#39;:4, &#39;A3&#39;:8, &#39;A4&#39;:0, &#39;A5&#39;:0, &#39;A6&#39;:7, &#39;A7&#39;:5, &#39;A8&#39;:0, &#39;A9&#39;:3,
    #                &#39;B1&#39;:3, &#39;B2&#39;:0, &#39;B3&#39;:2, &#39;B4&#39;:0, &#39;B5&#39;:4, &#39;B6&#39;:0, &#39;B7&#39;:9, &#39;B8&#39;:0, &#39;B9&#39;:1,
    #                   :
    #                   :
    #                &#39;I1&#39;:2, &#39;I2&#39;:8, &#39;I3&#39;:4, &#39;I4&#39;:0, &#39;I5&#39;:6, &#39;I6&#39;:0, &#39;I7&#39;:0, &#39;I8&#39;:3, &#39;I9&#39;:9,}
    #&#39;0&#39; values indicate unassigned variables and will not be printed.                         

    s = &#34;&#34;
    line = &#34;-------------------------------------\n&#34;
    s += line
    for row in &#34;ABCDEFGHI&#34;:
        s += &#34;|&#34;
        for col in &#34;123456789&#34;:
            if sudokuAssign[row + col] != 0:
                s += (&#34;%3d&#34; % sudokuAssign[row + col]) + &#34;|&#34;
            else:
                s += (&#34;%3c&#34; % &#39; &#39;) + &#34;|&#34;
        s += &#34;\n&#34; + line
    
    # print(s)
           
def main(sudokuStrStart):
    #Initialize sudoku assignments, domain, and constraints
    sudokuAssign, sudokuDomain, constraintList = createSudokuCsp()
    
    #Load sudoku starting board
    index = -1
    for j in &#39;ABCDEFGHI&#39;:
        for i in &#39;123456789&#39;:
            key = j+i
            index = index + 1
            sudokuAssign[key<span class='highlight-red'>] = int(sudokuStrStart[index])
            if int(sudokuStrStart[index]) != 0:
                sudokuDomain[</span>key] = [int(sudokuStrStart[index])]
    
    print(&#39;Starting sudoku board&#39;)
    visualizeBoard(sudokuAssign)

    #Run AC3 algorithm first.             
    flag, sudokuAssignNew, sudokuDomainNew = AC3(copy.deepcopy(sudokuAssign),copy.deepcopy(sudokuDomain), copy.deepcopy(constraintList))

    # print(flag)
    # print(sudokuAssignNew)
    # print(sudokuDomainNew)
    algoName = &#39;AC3&#39;
    #If the assignment is consistent after AC3, copy the assigned values into respective variables 
    if flag == True:
        sudokuAssign = sudokuAssignNew
        sudokuDomain = sudokuDomainNew


    if all(value&gt;0 for key,value in sudokuAssignNew.items()):
        pass #All variables have been successfully assigned by AC3 algorithm 
    else: #If AC3 fails, use the reduced domain space and BTS to solve the puzzle
        print(&#39;Mid sudoku board&#39;)
        visualizeBoard(sudokuAssign) 
        flag, sudokuAssign, sudokuDomain = backtracksearch(copy.deepcopy(sudokuAssign),copy.deepcopy(sudokuDomain))
        algoName = &#39;BTS&#39;
    
    print(&#39;Completed sudoku board&#39;)
    visualizeBoard(sudokuAssign) 
    
    #Create the sudoku string from the sudoku assignment dictionary
    sudokuStrFinish = &#39;&#39;
    index = -1
    for j in &#39;ABCDEFGHI&#39;:
        for i in &#39;123456789&#39;:
            key = j+i
            sudokuStrFinish = sudokuStrFinish + str(sudokuAssign[key])

    #Write output to file
    file = open(&#34;output.txt&#34;,&#34;w&#34;)
    file.write(&#39;{} {}&#39;.format(sudokuStrFinish,algoName)<span class='highlight-red'>)
    file.close()
    
if __name__ == &#34;__main__&#34;:
    #Input sudoku string
    sudokuStrStart = sys.argv[1]
#    sudokuStrStart = &#39;000000000302540000050301070000000004409006005023054790000000050700810000080060009&#39;
    #Call main function
    main(sudokuStrStart)</span>
</code></pre>
        </div>
        <div class="col" style="max-width: 600px">
          <pre><code>import sys
from itertools import permutations
from copy import deepcopy
from queue import *

sudokuAssign = None
sudokuDomain = None
constrainList = None
sudokuConstraint = None
domain = [1, 2, 3, 4, 5, 6, 7, 8, 9]
word = <span class='highlight-green'>[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;]
</span>number = [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;]




def AC3(sudokuAssign, sudokuDomain, constraintList):
    global sudokuConstraint
    q = <span class='highlight-green'>Queue()

    for c in constraintList:
        q.put(c)

    while not q.empty():
        temp </span>= q.get()
        Xi = temp[0]
        Xj = temp[1]
        
        <span class='highlight-green'>flag = False
        for x in sudokuDomain[Xi]:
            if not any(y != x for y in sudokuDomain[Xj]):
                sudokuDomain[Xi].remove(x)
                flag = True

        </span>if flag:
            if sudokuDomain[Xi] == []:
                return (False, sudokuAssign, sudokuDomain)
                
            neighbours = [Xk for Xi, Xk in sudokuConstraint[Xi]]
            for Xk in neighbours:

                q.put((Xk,Xi))

    <span class='highlight-green'>for key,value in sudokuDomain.items():
        if len(value) == 1:
            sudokuAssign[key] = value[0]

    return </span>(True, sudokuAssign, sudokuDomain)

    
    
def createSudokuCsp():
    global sudokuConstraint
    
    
    
    
    <span class='highlight-green'>sudokuBoard = [[&#39;A1&#39;, &#39;A2&#39;, &#39;A3&#39;, &#39;A4&#39;, &#39;A5&#39;, &#39;A6&#39;, &#39;A7&#39;, &#39;A8&#39;, &#39;A9&#39;],
                   [&#39;B1&#39;, &#39;B2&#39;, &#39;B3&#39;, &#39;B4&#39;, &#39;B5&#39;, &#39;B6&#39;</span>, &#39;B7&#39;, &#39;B8&#39;, &#39;B9&#39;],
                   [&#39;C1&#39;, &#39;C2&#39;, &#39;C3&#39;, &#39;C4&#39;, &#39;C5&#39;, &#39;C6&#39;, &#39;C7&#39;, &#39;C8&#39;, &#39;C9&#39;],
                   [&#39;D1&#39;, &#39;D2&#39;, &#39;D3&#39;, &#39;D4&#39;, &#39;D5&#39;, &#39;D6&#39;, &#39;D7&#39;, &#39;D8&#39;, &#39;D9&#39;],
                   [&#39;E1&#39;, &#39;E2&#39;, &#39;E3&#39;, &#39;E4&#39;, &#39;E5&#39;, &#39;E6&#39;, &#39;E7&#39;, &#39;E8&#39;, &#39;E9&#39;],
                   [&#39;F1&#39;, &#39;F2&#39;, &#39;F3&#39;, &#39;F4&#39;, &#39;F5&#39;, &#39;F6&#39;, &#39;F7&#39;, &#39;F8&#39;, &#39;F9&#39;],
                   [&#39;G1&#39;, &#39;G2&#39;, &#39;G3&#39;, &#39;G4&#39;, &#39;G5&#39;, &#39;G6&#39;, &#39;G7&#39;, &#39;G8&#39;, &#39;G9&#39;],
                   [&#39;H1&#39;, &#39;H2&#39;, &#39;H3&#39;, &#39;H4&#39;, &#39;H5&#39;, &#39;H6&#39;, &#39;H7&#39;, &#39;H8&#39;, &#39;H9&#39;],
                   [&#39;I1&#39;, &#39;I2&#39;, &#39;I3&#39;, <span class='highlight-green'>&#39;I4&#39;, &#39;I5&#39;, &#39;I6&#39;, &#39;I7&#39;, &#39;I8&#39;, &#39;I9&#39;]]
 

    sudokuDomain = {</span>}

    for row in sudokuBoard:
        for key in row:
            sudokuDomain[key] = list(domain)
    
    # sudokuAssign = {key:0 for key in sudokuDomain}

    sudokuAssign = {}
    for key in sudokuDomain:
        sudokuAssign[key] = 0


   
    constraintList = []
    
    for row in sudokuBoard:       
        constraintList += list(<span class='highlight-green'>permutations(row,2))

    Transpose = list(map(list, zip(*sudokuBoard)))  #Transpose the
    
    for col in Transpose:       
        constraintList </span>+= list(<span class='highlight-green'>permutations(col, 2))
        
    #Constraints within each 3x3 square

    for row in [0,3,6]:
        for col in [0,3,6]:
            box = [</span>]
            for i in range(row, row+3):
                for j in range(col, col+3):
                    val = sudokuBoard[i][j]
                    box.append(val)

            constraintList += list(permutations(box,2))

    constraintList = list(set(constraintList))
    
   
    sudokuConstraint = {}
    for key in sudokuDomain:
        sudokuConstraint[key] = []

    

    for val in constraintList:
        xi = val[0]
        sudokuConstraint[xi<span class='highlight-green'>].append(val) 
    
  
    return sudokuAssign, sudokuDomain, constraintList

# backtracking search function
# -------------------------------- 


def consistent(sudokuAssign, sudokuDomain, chosenKey, value):
    global sudokuConstraint
    
    constraintList = sudokuConstraint[chosenKey]
    for xi</span>, xj in constraintList:
        if value == xj<span class='highlight-green'>:
            return False 
    return True

def inference(X, D, chosenKey, value):
    

    global sudokuConstraint
    
    constraintList = sudokuConstraint</span>[chosenKey]
    for xi, xj in constraintList:
        check = xj
        <span class='highlight-green'>if X[check] == 0: 
            if value in D[check]:
                D[check].remove(value)
            </span>else:
                if D[check] == [<span class='highlight-green'>]: 
                    return (False, X, D)
    return (True, X, D)
    
def backtracking(X, D):  

    </span>flag = True
    
    for key, value in X.items():
        if value == 0:
            flag = False

    if flag:
        return (flag, X, D)

    chosenKey = None
    MRV = 10000
    for row in word:
        for col in number:
            hash_key = row + col
            if X[hash_key] == 0: #Consider only unassigned variables
                value = D[hash_key]
                if len(value) &lt; MRV:
                    MRV = min(MRV, len(value))
                    chosenKey = hash_key 

    <span class='highlight-green'>for value in D[chosenKey]:
        if consistent(X, D, chosenKey, value):
            X_New = deepcopy</span>(X)
            D_New = deepcopy(D)
            X_New[chosenKey] = value
            D_New[chosenKey] = [value]

            a, b, c= inference(X_New, D_New, chosenKey, value)
            if a == True:
                resultBTS = backtracking(b,c<span class='highlight-green'>)
                if resultBTS[0] == True:
                    return resultBTS
    return (False, X, D)

    
# -------------------------------- 





def main(sudokuStrStart</span>):
    temp = createSudokuCsp()
    sudokuAssign = temp[0]
    sudokuDomain = temp[1]
    constrainList = temp[2]

  


    index = -1
    letter_head = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;]
    number_head = [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;]
    for i in letter_head:
        for j in number_head:
            hash = i + j
            index += 1
            sudokuAssign[hash<span class='highlight-green'>] = int(sudokuStrStart[index])
            if int(sudokuStrStart[index]) != 0:
                sudokuDomain[</span>hash] = [int(sudokuStrStart[index])]
    
    sudukuAssignCopy = deepcopy(sudokuAssign)
    sudukuDomainCopy = deepcopy(sudokuDomain)
    constrainListCopy = deepcopy(constrainList)


 


    ref , new_assign, new_domain= AC3(sudukuAssignCopy, sudukuDomainCopy,  constrainListCopy)
    algo_name_1 = &#39;AC3&#39;
 

    if ref:
        sudokuAssign = new_assign
        sudokuDomain = new_domain

    flag = True

    
    # if flag is False, then use BTS
    for key, value in new_assign.items():
        if value == 0:
            flag = False

    if not flag:
      
        a, b, c = backtracking(deepcopy(sudokuAssign), deepcopy(sudokuDomain))

        algo_name_1 = &#34;BTS&#34;

        finish_state = &#39;&#39;

        for i in letter_head:
            for j in number_head:
                hash = i + j
                finish_state += str(b[hash])
        finish_state += &#34; &#34; + algo_name_1

        # write file
        file = open(&#34;output.txt&#34;, &#34;w&#34;)
    
        file.write(finish_state<span class='highlight-green'>)
        file.close()

   
if __name__ == &#34;__main__&#34;:
    #Input sudoku string
    start = sys.argv[1]
    main(start)




 </span></code></pre>
        </div>
      </div>
    </div>
  </div>
  </td>
  </tr>
  
  </tbody>
  </table>
</div>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-kQtW33rZJAHjgefvhyyzcGF3C5TFyBQBA13V1RKPf4uH+bwyzQxZ6CmMZHmNBEfJ" crossorigin="anonymous"></script>
</body>