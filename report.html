<!DOCTYPE HTML>
<html>
<head>
    <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Copy Detection Report</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-uWxY/CJNBR+1zjPWmfnSnVxwRheevXITnMqoEIeG1LJrdI0GlVs/9cVSyPYXdcSF" crossorigin="anonymous">
  <style>
    h1 {
      text-align: center;
    }
    .highlight-green {
      background-color: #b6f2b6;
    }
    .highlight-red {
      background-color: #f2b6b6;
    }
    pre {
      text-align: left;
    }
  </style>
</head>
<body>
<div class="container" style="margin-top: 3em; max-width: 1400px">
  <h1 style="margin-bottom: 1em;">Copy Detection Report</h1>
  <h2>Overview</h2>
    <div class="container d-flex justify-content-center">
      <div class="col">
        <h4 style="text-align: center;">Similarity Matrix</h4>
        <img src="data:image/png;base64, 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" alt="Code similarity matrix">
      </div>
      <div class="col">
        <h4 style="text-align: center;">Similarity Score Distribution</h4>
        <img src="data:image/png;base64, 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" alt="Code similarity histogram">
      </div>
    </div>
    <p style="text-align: center">
      <i>Note: a score of -1 in the similarity matrix indicates the comparison was skipped</i>
    </p>
    <p>
    Number of files tested: 3<br>
    Number of reference files: 3<br>
    Test files above display threshold: 2 (66.67%)<br><br>
    </p>

  <h2>Matched Code</h2>
  <table class="table table-striped table-sm">
  <tbody class="table-light">
  
  <tr>
  <td style="text-align: center;">
  <p>
    Test file: <i>hw2/puzzle.py</i> (<b>44.21%</b>)<br>
    Reference file: <i>hw2/reference/driver_3.py</i> (<b>40.49%</b>)<br>
    Token overlap: 698<br><br>
    <button class="btn btn-secondary" type="button" data-bs-toggle="collapse" data-bs-target="#collapse-1" aria-expanded="false" aria-controls="collapse-1">
      View matched code
    </button>
  </p>
  <div class="collapse" id="collapse-1">
    <div class="card card-body">
      <div class="row">
        <div class="col" style="max-width: 600px">
          <pre><code>import sys
from itertools import permutations
from copy import deepcopy
from queue import *

sudokuAssign = None
sudokuDomain = None
constrainList = None
sudokuConstraint = None
domain = [1, 2, 3, 4, 5, 6, 7, 8, 9]
word = <span class='highlight-red'>[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;]
</span>number = [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;]




def AC3(sudokuAssign, sudokuDomain, constraintList):
    global sudokuConstraint
    q = <span class='highlight-red'>Queue()

    for c in constraintList:
        q.put(c)

    while not q.empty():
        temp </span>= q.get()
        Xi = temp[0]
        Xj = temp[1]
        
        <span class='highlight-red'>flag = False
        for x in sudokuDomain[Xi]:
            if not any(y != x for y in sudokuDomain[Xj]):
                sudokuDomain[Xi].remove(x)
                flag = True

        </span>if flag<span class='highlight-red'>:
            if not sudokuDomain[Xi]:
                return (False, sudokuAssign, sudokuDomain)
                
            </span>neighbours = [Xk for Xi, Xk in sudokuConstraint[Xi]]
            for Xk in neighbours:

                q.put((Xk,Xi))

    <span class='highlight-red'>for key,value in sudokuDomain.items():
        if len(value) == 1:
            sudokuAssign[key] = value[0]

    return </span>(True, sudokuAssign, sudokuDomain)

    
    
def createSudokuCsp():
    global sudokuConstraint
    
    
    
    
    <span class='highlight-red'>sudokuBoard = [[&#39;A1&#39;, &#39;A2&#39;, &#39;A3&#39;, &#39;A4&#39;, &#39;A5&#39;, &#39;A6&#39;, &#39;A7&#39;, &#39;A8&#39;, &#39;A9&#39;],
                   [&#39;B1&#39;, &#39;B2&#39;, &#39;B3&#39;, &#39;B4&#39;, &#39;B5&#39;, &#39;B6&#39;</span>, &#39;B7&#39;, &#39;B8&#39;, &#39;B9&#39;],
                   [&#39;C1&#39;, &#39;C2&#39;, &#39;C3&#39;, &#39;C4&#39;, &#39;C5&#39;, &#39;C6&#39;, &#39;C7&#39;, &#39;C8&#39;, &#39;C9&#39;],
                   [&#39;D1&#39;, &#39;D2&#39;, &#39;D3&#39;, &#39;D4&#39;, &#39;D5&#39;, &#39;D6&#39;, &#39;D7&#39;, &#39;D8&#39;, &#39;D9&#39;],
                   [&#39;E1&#39;, &#39;E2&#39;, &#39;E3&#39;, &#39;E4&#39;, &#39;E5&#39;, &#39;E6&#39;, &#39;E7&#39;, &#39;E8&#39;, &#39;E9&#39;],
                   [&#39;F1&#39;, &#39;F2&#39;, &#39;F3&#39;, &#39;F4&#39;, &#39;F5&#39;, &#39;F6&#39;, &#39;F7&#39;, &#39;F8&#39;, &#39;F9&#39;],
                   [&#39;G1&#39;, &#39;G2&#39;, &#39;G3&#39;, &#39;G4&#39;, &#39;G5&#39;, &#39;G6&#39;, &#39;G7&#39;, &#39;G8&#39;, &#39;G9&#39;],
                   [&#39;H1&#39;, &#39;H2&#39;, &#39;H3&#39;, &#39;H4&#39;, &#39;H5&#39;, &#39;H6&#39;, &#39;H7&#39;, &#39;H8&#39;, &#39;H9&#39;],
                   [&#39;I1&#39;, &#39;I2&#39;, &#39;I3&#39;, <span class='highlight-red'>&#39;I4&#39;, &#39;I5&#39;, &#39;I6&#39;, &#39;I7&#39;, &#39;I8&#39;, &#39;I9&#39;]]
 

    sudokuDomain = {</span>}

    for row in sudokuBoard:
        for key in row:
            sudokuDomain[key] = list(domain)
    
    # sudokuAssign = {key:0 for key in sudokuDomain}

    sudokuAssign = {}
    for key in sudokuDomain:
        sudokuAssign[key] = 0


   
    constraintList = []
    
    for row in sudokuBoard:       
        constraintList += list(<span class='highlight-red'>permutations(row,2))

    Transpose = list(map(list, zip(*sudokuBoard)))  #Transpose the
    
    for col in Transpose:       
        constraintList </span>+= list(<span class='highlight-red'>permutations(col, 2))
        
    #Constraints within each 3x3 square

    for row in [0,3,6]:
        for col in [0,3,6]:
            box = [</span>]
            for i in range(row, row+3):
                for j in range(col, col+3):
                    val = sudokuBoard[i][j]
                    box.append(val)

            constraintList += list(permutations(box,2))

    constraintList = list(set(constraintList))
    
   
    sudokuConstraint = {}
    for key in sudokuDomain:
        sudokuConstraint[key] = []

    

    for val in constraintList:
        xi = val[0]
        sudokuConstraint[xi<span class='highlight-red'>].append(val) 
    
  
    return sudokuAssign, sudokuDomain, constraintList

# backtracking search function
# -------------------------------- 


def consistent(sudokuAssign, sudokuDomain, chosenKey, value):
    global sudokuConstraint
    
    constraintList = sudokuConstraint[chosenKey]
    for xi</span>, xj in constraintList:
        if value == xj<span class='highlight-red'>:
            return False 
    return True

def inference(X, D, chosenKey, value):
    

    global sudokuConstraint
    
    constraintList = sudokuConstraint</span>[chosenKey]
    for xi, xj in constraintList:
        check = xj
        <span class='highlight-red'>if X[check] == 0: 
            if value in D[check]:
                D[check].remove(value)
            </span>else:
                if D[check] == [<span class='highlight-red'>]: 
                    return (False, X, D)
    return (True, X, D)
    
def backtracking(X, D):  

    </span>flag = True
    
    for key, value in X.items():
        if value == 0:
            flag = False

    if flag:
        return (flag, X, D)

    chosenKey = None
    MRV = 10000
    for row in word:
        for col in number<span class='highlight-red'>:
            if X[row+col] == 0: #Consider only unassigned variables
                value = D[row+col]
                if len(value) &lt; MRV:
                    MRV = </span>min(MRV, len(value))
                    chosenKey = row+col 

    <span class='highlight-red'>for value in D[chosenKey]:
        if consistent(X, D, chosenKey, value):
            X_New = deepcopy</span>(X)
            D_New = deepcopy(D)
            X_New[chosenKey] = value
            D_New[chosenKey] = [value]

            a, b, c= inference(X_New, D_New, chosenKey, value)
            if a == True:
                resultBTS = backtracking(b,c<span class='highlight-red'>)
                if resultBTS[0] == True:
                    return resultBTS
    return (False, X, D)

    
# -------------------------------- 





def main(sudokuStrStart</span>):
    temp = createSudokuCsp()
    sudokuAssign = temp[0]
    sudokuDomain = temp[1]
    constrainList = temp[2]

  


    index = -1
    letter_head = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;]
    number_head = [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;]
    for i in letter_head:
        for j in number_head:
            hash = i + j
            index += 1
            sudokuAssign[hash<span class='highlight-red'>] = int(sudokuStrStart[index])
            if int(sudokuStrStart[index]) != 0:
                sudokuDomain[</span>hash] = [int(sudokuStrStart[index])]
    
    sudukuAssignCopy = deepcopy(sudokuAssign)
    sudukuDomainCopy = deepcopy(sudokuDomain)
    constrainListCopy = deepcopy(constrainList)


 


    ref , new_assign, new_domain= AC3(sudukuAssignCopy, sudukuDomainCopy,  constrainListCopy)
    algo_name_1 = &#39;AC3&#39;
    algo_name_2 = &#39;BTS&#39;

    if ref:
        sudokuAssign = new_assign
        sudokuDomain = new_domain

    flag = True

    
    # if flag is False, then use BTS
    for key, value in new_assign.items():
        if value == 0:
            flag = False

    if not flag:
      
        a, b, c = backtracking(deepcopy(sudokuAssign), deepcopy(sudokuDomain))
        print(b<span class='highlight-red'>)


   
if __name__ == &#34;__main__&#34;:
    #Input sudoku string
    start = sys.argv[1]
    main(start)




 </span></code></pre>
        </div>
        <div class="col" style="max-width: 600px">
          <pre><code># -*- coding: utf-8 -*-

import sys
import copy
import itertools
import queue
    
def createSudokuCsp():
    global sudokuConstraint
    
    #Create domain values
    domain = [1,2,3,4,5,6,7,8,9]
    #Create sudoku board containing all the variables
    <span class='highlight-green'>sudokuBoard = [[&#39;A1&#39;, &#39;A2&#39;, &#39;A3&#39;, &#39;A4&#39;, &#39;A5&#39;, &#39;A6&#39;, &#39;A7&#39;, &#39;A8&#39;, &#39;A9&#39;],
                   [&#39;B1&#39;, &#39;B2&#39;, &#39;B3&#39;, &#39;B4&#39;, &#39;B5&#39;, &#39;B6&#39;</span>, &#39;B7&#39;, &#39;B8&#39;, &#39;B9&#39;],
                   [&#39;C1&#39;, &#39;C2&#39;, &#39;C3&#39;, &#39;C4&#39;, &#39;C5&#39;, &#39;C6&#39;, &#39;C7&#39;, &#39;C8&#39;, &#39;C9&#39;],
                   [&#39;D1&#39;, &#39;D2&#39;, &#39;D3&#39;, &#39;D4&#39;, &#39;D5&#39;, &#39;D6&#39;, &#39;D7&#39;, &#39;D8&#39;, &#39;D9&#39;],
                   [&#39;E1&#39;, &#39;E2&#39;, &#39;E3&#39;, &#39;E4&#39;, &#39;E5&#39;, &#39;E6&#39;, &#39;E7&#39;, &#39;E8&#39;, &#39;E9&#39;],
                   [&#39;F1&#39;, &#39;F2&#39;, &#39;F3&#39;, &#39;F4&#39;, &#39;F5&#39;, &#39;F6&#39;, &#39;F7&#39;, &#39;F8&#39;, &#39;F9&#39;],
                   [&#39;G1&#39;, &#39;G2&#39;, &#39;G3&#39;, &#39;G4&#39;, &#39;G5&#39;, &#39;G6&#39;, &#39;G7&#39;, &#39;G8&#39;, &#39;G9&#39;],
                   [&#39;H1&#39;, &#39;H2&#39;, &#39;H3&#39;, &#39;H4&#39;, &#39;H5&#39;, &#39;H6&#39;, &#39;H7&#39;, &#39;H8&#39;, &#39;H9&#39;],
                   [&#39;I1&#39;, &#39;I2&#39;, &#39;I3&#39;, <span class='highlight-green'>&#39;I4&#39;, &#39;I5&#39;, &#39;I6&#39;, &#39;I7&#39;, &#39;I8&#39;, &#39;I9&#39;]]
    #Assign domain values for each variable
    sudokuDomain = {</span>key:list(domain) for row in sudokuBoard for key in row}
    #Create a copy of sudoku dictionary to store value assignment for each variable   
    sudokuAssign = {key:0 for key in sudokuDomain}

    #Create constraints
    constraintList = []
    #Constraints along row
    for row in sudokuBoard:       
        constraintList = constraintList + list(itertools.<span class='highlight-green'>permutations(row,2))
    #Constraints along column
    sudokuBoardT = list(map(list,zip(*sudokuBoard))) #Transpose the sudoku board 
    
    for col in sudokuBoardT:       
        constraintList </span>= constraintList + list(itertools.<span class='highlight-green'>permutations(col,2))
    #Constraints within each 3x3 square
    for row in [0,3,6]:
        for col in [0,3,6]:
            box = [</span>val for row in sudokuBoard[row:row+3] for val in row[col:col+3]]    
            constraintList = constraintList + list(itertools.permutations(box,2))
    #Remove duplicate constraints
    constraintList = list(set(constraintList))
    #Create a dictionary to store constraints. Initialize constraints to empty lists.
    sudokuConstraint = {key:list([]) for key in sudokuDomain} 
    #Associate the constraints with their respective keys in a dictionary
    for val in constraintList:
        sudokuConstraint[val[0]<span class='highlight-green'>].append(val)



    return sudokuAssign, sudokuDomain, constraintList

def selectUnassignedVariable(sudokuAssign,sudokuDomain</span>):
    #Minimum remaining values heuristic is used
    MRV = 100 #A randomly chosen number larger than domain size
    for row in &#39;ABCDEFGHI&#39;:
        for col in &#39;123456789&#39;<span class='highlight-green'>:
            if sudokuAssign[row+col] == 0: #Consider only unassigned variables
                value = sudokuDomain[row+col]
                if len(value) &lt; MRV:
                    MRV = </span>len(value)
                    chosenKey = row+col 
    return <span class='highlight-green'>chosenKey 

def consistent(sudokuAssign, sudokuDomain, chosenKey, value):
    global sudokuConstraint
    
    constraintList = sudokuConstraint[chosenKey]
    for constraint </span>in constraintList:
        if value == sudokuAssign[constraint[1]]<span class='highlight-green'>:
            return False 
    return True

def inference(sudokuAssign, sudokuDomain, chosenKey, value):
    #This inference function implements forward checking

    global sudokuConstraint
    
    constraintList = sudokuConstraint</span>[chosenKey]
    for constraint in constraintList:
        checkKey = constraint[1]
        <span class='highlight-green'>if sudokuAssign[checkKey] == 0: #Perform forward checking only on unassigned variables
            if value in sudokuDomain[checkKey]:
                sudokuDomain[checkKey].remove(value)
            </span><span class='highlight-green'>if not sudokuDomain[checkKey]: #If domain is empty, i.e., no legal values remaining 
                return (False, sudokuAssign, sudokuDomain)
    return (True, sudokuAssign, sudokuDomain)
    
def backtracksearch(sudokuAssign,sudokuDomain):  
    #Check if assignment is complete
    </span>if all(value&gt;0 for key,value in sudokuAssign.items()):
        return (True, sudokuAssign, sudokuDomain)
    chosenKey = selectUnassignedVariable(sudokuAssign, sudokuDomain)
    # print(chosenKey)
    <span class='highlight-green'>for value in sudokuDomain[chosenKey]:
        if consistent(sudokuAssign, sudokuDomain, chosenKey, value):
            sudokuAssignNew = copy</span>.deepcopy(sudokuAssign)
            sudokuDomainNew = copy.deepcopy(sudokuDomain)
            sudokuAssignNew[chosenKey] = value
            sudokuDomainNew[chosenKey] = [value]
            resultInference = inference(sudokuAssignNew, sudokuDomainNew, chosenKey, value)
            if resultInference[0] == True:
                resultBTS = backtracksearch(resultInference[1],resultInference[2]<span class='highlight-green'>)
                if resultBTS[0] == True:
                    return resultBTS
    return (False, sudokuAssign, sudokuDomain)

def makeAssign(sudokuAssign</span>, sudokuDomain):
    <span class='highlight-green'>for key,value in sudokuDomain.items():
        if len(value) == 1:
            sudokuAssign[key] = value[0]
    return </span>sudokuAssign    

def getNeighbours(Xi):
    global sudokuConstraint
    neighbours = [Xk for Xi, Xk in sudokuConstraint[Xi]]
    return neighbours
    
def revise(sudokuDomain, Xi, Xj):
    <span class='highlight-green'>revised = False
    for x in sudokuDomain[Xi]:
        if not any(y!=x for y in sudokuDomain[Xj]):
            sudokuDomain[Xi].remove(x)
            revised = True
    </span>return revised

def AC3(sudokuAssign,sudokuDomain, constraintList):  
    q = queue.<span class='highlight-green'>Queue()
    for constraint in constraintList:
        q.put(constraint)
    while not q.empty():
        Xi</span>,Xj = q.get()
        if revise(sudokuDomain, Xi, Xj)<span class='highlight-green'>:
            if not sudokuDomain[Xi]:
                return (False, sudokuAssign</span>, sudokuDomain)
            for Xk in getNeighbours(Xi):
                q.put((Xk,Xi))
    sudokuAssign = makeAssign(sudokuAssign, sudokuDomain)
    return (True, sudokuAssign, sudokuDomain)

def visualizeBoard(sudokuAssign):
    #Prints a sudoku grid containing the assigned variables.
    #This function accepts a dictionary of the form:
    #sudokuAssign = {&#39;A1&#39;:1, &#39;A2&#39;:4, &#39;A3&#39;:8, &#39;A4&#39;:0, &#39;A5&#39;:0, &#39;A6&#39;:7, &#39;A7&#39;:5, &#39;A8&#39;:0, &#39;A9&#39;:3,
    #                &#39;B1&#39;:3, &#39;B2&#39;:0, &#39;B3&#39;:2, &#39;B4&#39;:0, &#39;B5&#39;:4, &#39;B6&#39;:0, &#39;B7&#39;:9, &#39;B8&#39;:0, &#39;B9&#39;:1,
    #                   :
    #                   :
    #                &#39;I1&#39;:2, &#39;I2&#39;:8, &#39;I3&#39;:4, &#39;I4&#39;:0, &#39;I5&#39;:6, &#39;I6&#39;:0, &#39;I7&#39;:0, &#39;I8&#39;:3, &#39;I9&#39;:9,}
    #&#39;0&#39; values indicate unassigned variables and will not be printed.                         

    s = &#34;&#34;
    line = &#34;-------------------------------------\n&#34;
    s += line
    for row in &#34;ABCDEFGHI&#34;:
        s += &#34;|&#34;
        for col in &#34;123456789&#34;:
            if sudokuAssign[row + col] != 0:
                s += (&#34;%3d&#34; % sudokuAssign[row + col]) + &#34;|&#34;
            else:
                s += (&#34;%3c&#34; % &#39; &#39;) + &#34;|&#34;
        s += &#34;\n&#34; + line
    
    # print(s)
           
def main(sudokuStrStart):
    #Initialize sudoku assignments, domain, and constraints
    sudokuAssign, sudokuDomain, constraintList = createSudokuCsp()
    
    #Load sudoku starting board
    index = -1
    for j in &#39;ABCDEFGHI&#39;:
        for i in &#39;123456789&#39;:
            key = j+i
            index = index + 1
            sudokuAssign[key<span class='highlight-green'>] = int(sudokuStrStart[index])
            if int(sudokuStrStart[index]) != 0:
                sudokuDomain[</span>key] = [int(sudokuStrStart[index])]
    
    print(&#39;Starting sudoku board&#39;)
    visualizeBoard(sudokuAssign)

    #Run AC3 algorithm first.             
    flag, sudokuAssignNew, sudokuDomainNew = AC3(copy.deepcopy(sudokuAssign),copy.deepcopy(sudokuDomain), copy.deepcopy(constraintList))

    # print(flag)
    # print(sudokuAssignNew)
    # print(sudokuDomainNew)
    algoName = &#39;AC3&#39;
    #If the assignment is consistent after AC3, copy the assigned values into respective variables 
    if flag == True:
        sudokuAssign = sudokuAssignNew
        sudokuDomain = sudokuDomainNew


    if all(value&gt;0 for key,value in sudokuAssignNew.items()):
        pass #All variables have been successfully assigned by AC3 algorithm 
    else: #If AC3 fails, use the reduced domain space and BTS to solve the puzzle
        print(&#39;Mid sudoku board&#39;)
        visualizeBoard(sudokuAssign) 
        flag, sudokuAssign, sudokuDomain = backtracksearch(copy.deepcopy(sudokuAssign),copy.deepcopy(sudokuDomain))
        algoName = &#39;BTS&#39;
    
    print(&#39;Completed sudoku board&#39;)
    visualizeBoard(sudokuAssign) 
    
    #Create the sudoku string from the sudoku assignment dictionary
    sudokuStrFinish = &#39;&#39;
    index = -1
    for j in &#39;ABCDEFGHI&#39;:
        for i in &#39;123456789&#39;:
            key = j+i
            sudokuStrFinish = sudokuStrFinish + str(sudokuAssign[key])

    #Write output to file
    file = open(&#34;output.txt&#34;,&#34;w&#34;)
    file.write(&#39;{} {}&#39;.format(sudokuStrFinish,algoName))
    file.close(<span class='highlight-green'>)
    
if __name__ == &#34;__main__&#34;:
    #Input sudoku string
    sudokuStrStart = sys.argv[1]
#    sudokuStrStart = &#39;000000000302540000050301070000000004409006005023054790000000050700810000080060009&#39;
    #Call main function
    main(sudokuStrStart)</span>
</code></pre>
        </div>
      </div>
    </div>
  </div>
  </td>
  </tr>
  
  </tbody>
  </table>
</div>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-kQtW33rZJAHjgefvhyyzcGF3C5TFyBQBA13V1RKPf4uH+bwyzQxZ6CmMZHmNBEfJ" crossorigin="anonymous"></script>
</body>