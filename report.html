<!DOCTYPE HTML>
<html>
<head>
    <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Copy Detection Report</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-uWxY/CJNBR+1zjPWmfnSnVxwRheevXITnMqoEIeG1LJrdI0GlVs/9cVSyPYXdcSF" crossorigin="anonymous">
  <style>
    h1 {
      text-align: center;
    }
    .highlight-green {
      background-color: #b6f2b6;
    }
    .highlight-red {
      background-color: #f2b6b6;
    }
    pre {
      text-align: left;
    }
  </style>
</head>
<body>
<div class="container" style="margin-top: 3em; max-width: 1400px">
  <h1 style="margin-bottom: 1em;">Copy Detection Report</h1>
  <h2>Overview</h2>
    <div class="container d-flex justify-content-center">
      <div class="col">
        <h4 style="text-align: center;">Similarity Matrix</h4>
        <img src="data:image/png;base64, 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8Co4x6IEDAAA4DJkAAEAgBGWFZRl2fP4FrvGQT8ygAAAAC5DBhAAAJhhWfbdu8ciEFsRAAIAADMsGxeBEADaihIwAACAy5ABBAAAZgSDksemxRssArEVASAAADCDErBjUQIGAABwGTKAAADACCsYlGVTCZjnANqLDCAAAIDLkAEEAABmcA+gYxEAAgAAM4KW5CEAdCJKwAAAAC5DBhAAAJhhWZLseg4gGUA7kQEEAABwGTKAAADACCtoybLpHkCLDKCtCAABAIAZVlD2lYB5DqCd4roEXFVVpdmzZ2vkyJFKS0vTggUL1NbWdsp96urq5PF4wlpSUtIgzRgAAMC8uA4AX3vtNS1dulRvvvmmGhoadPz4cV155ZXq6ek55X4+n08HDx4Mtf379w/SjAEAiB9W0LK1wT5xXQKur68P+1xXV6e0tDS1tLRo3rx5UffzeDzKyMgwPT0AAICYiOsA8Ou6urokSampqafsd+zYMY0fP17BYFCXXHKJ/vVf/1UXXXRRxL69vb3q7e096RjBT3sj9ge+7nPreKyngCGku7s71lPAEHLi+xKrBRSfW7223bv3ufittJPHcsmymmAwqO9///s6evSoNm/eHLVfc3Oz/vKXv2jGjBnq6urSqlWr9Prrr2vXrl06//zzT+p/33336f777zc5dQAAzsrevXs1ceLEQTveZ599pgkTJsjv99s6bkZGhvbt28e9+TZwTQB4++236w9/+IM2b94cMZCL5vjx45o6daoWLVqklStXnvT3r2cAjx49qvHjx6u9vV0pKSm2zD1edHd3KysrSx0dHfL5fLGejmNwXSLjukTGdYmM6xJZV1eXLrjgAn300UcaNWrUoB77s88+U19fn61jJiQkEPzZxBUl4PLycv3ud7/T66+/PqDgT5KGDx+umTNnas+ePRH/npiYqMTExJO2p6Sk8CMUhc/n49pEwHWJjOsSGdclMq5LZF7v4K/5TEpKIlhzsLheBWxZlsrLy/XCCy9o06ZNmjBhwoDHCAQC2rlzpzIzMw3MEAAAYPDFdQZw6dKlWr9+vV588UWNHDkydC9CSkqKzj33XElSSUmJxo0bp6qqKknSihUrdOmll2rSpEk6evSoHnroIe3fv1+33HJLzM4DAADATnEdAD766KOSpMLCwrDtTz75pH784x9Lktrb28NS4x999JHKysrk9/s1evRo5eXlacuWLZo2bdppHTMxMVHLly+PWBZ2O65NZFyXyLgukXFdIuO6RMZ1QTSuWQQCAACAfnF9DyAAAABORgAIAADgMgSAAAAALkMACAAA4DIEgDb48MMPddNNN8nn82nUqFFasmSJjh07dsp9CgsL5fF4wtptt902SDM2p7q6WtnZ2UpKSlJ+fr62bt16yv7PPvuspkyZoqSkJF188cV66aWXBmmmg2sg16Wuru6k70a8PUz19ddf17XXXquxY8fK4/Fo48aN37hPU1OTLrnkEiUmJmrSpEmqq6szPs9YGOi1aWpqOun74vF4bH8FVyxVVVVp9uzZGjlypNLS0rRgwQK1tbV9437x/vtyJtfFDb8vOD0EgDa46aabtGvXLjU0NITeOHLrrbd+435lZWU6ePBgqP3yl78chNmas2HDBlVUVGj58uXavn27cnJyVFxcrEOHDkXsv2XLFi1atEhLlizRjh07tGDBAi1YsEBvv/32IM/crIFeF6n/bQZf/W7s379/EGdsXk9Pj3JyclRdXX1a/fft26drrrlGl19+uVpbW3XnnXfqlltu0csvv2x4poNvoNfmhLa2trDvTFpamqEZDr7XXntNS5cu1ZtvvqmGhgYdP35cV155pXp6eqLu44bflzO5LlL8/77gNFk4K++8844lyfrTn/4U2vaHP/zB8ng81oEDB6LuN3/+fOuOO+4YhBkOnjlz5lhLly4NfQ4EAtbYsWOtqqqqiP3/7u/+zrrmmmvCtuXn51s/+clPjM5zsA30ujz55JNWSkrKIM0u9iRZL7zwwin73HPPPdZFF10Utm3hwoVWcXGxwZnF3ulcm1dffdWSZH300UeDMicnOHTokCXJeu2116L2ccvvy1edznVx2+8LoiMDeJaam5s1atQozZo1K7StqKhIXq9Xb7311in3ffrppzVmzBhNnz5dlZWV+uSTT0xP15i+vj61tLSoqKgotM3r9aqoqEjNzc0R92lubg7rL0nFxcVR+w9FZ3JdJOnYsWMaP368srKydN1112nXrl2DMV3HcsN35Wzl5uYqMzNT3/3ud/XGG2/EejpGdXV1SZJSU1Oj9nHjd+Z0rovE7wv6EQCeJb/ff1Kp5ZxzzlFqauop78H54Q9/qHXr1unVV19VZWWlnnrqKf3oRz8yPV1jjhw5okAgoPT09LDt6enpUa+D3+8fUP+h6Eyuy+TJk1VbW6sXX3xR69atUzAY1Ny5c/XBBx8MxpQdKdp3pbu7W59++mmMZuUMmZmZqqmp0XPPPafnnntOWVlZKiws1Pbt22M9NSOCwaDuvPNOXXbZZZo+fXrUfm74ffmq070u/L7ghLh+FdzZuPfee/Xggw+ess/u3bvPePyv3iN48cUXKzMzU1dccYX27t2rCy+88IzHxdBXUFCggoKC0Oe5c+dq6tSpeuyxx7Ry5coYzgxONHnyZE2ePDn0ee7cudq7d6/WrFmjp556KoYzM2Pp0qV6++23tXnz5lhPxVFO97rw+4ITCACjuOuuu0LvC45m4sSJysjIOOlm/s8//1wffvihMjIyTvt4+fn5kqQ9e/YMyQBwzJgxGjZsmDo7O8O2d3Z2Rr0OGRkZA+o/FJ3Jdfm64cOHa+bMmdqzZ4+JKQ4J0b4rPp9P5557boxm5Vxz5syJywCpvLw8tNDu/PPPP2VfN/y+nDCQ6/J1/L64FyXgKM477zxNmTLllC0hIUEFBQU6evSoWlpaQvtu2rRJwWAwFNSdjtbWVkn95ZyhKCEhQXl5eWpsbAxtCwaDamxsDPvX5lcVFBSE9ZekhoaGqP2HojO5Ll8XCAS0c+fOIfvdsIMbvit2am1tjavvi2VZKi8v1wsvvKBNmzZpwoQJ37iPG74zZ3Jdvo7fFxeL9SqUeHDVVVdZM2fOtN566y1r8+bN1re+9S1r0aJFob9/8MEH1uTJk6233nrLsizL2rNnj7VixQpr27Zt1r59+6wXX3zRmjhxojVv3rxYnYItnnnmGSsxMdGqq6uz3nnnHevWW2+1Ro0aZfn9fsuyLOvmm2+27r333lD/N954wzrnnHOsVatWWbt377aWL19uDR8+3Nq5c2esTsGIgV6X+++/33r55ZetvXv3Wi0tLdaNN95oJSUlWbt27YrVKdju448/tnbs2GHt2LHDkmStXr3a2rFjh7V//37Lsizr3nvvtW6++eZQ//fee89KTk627r77bmv37t1WdXW1NWzYMKu+vj5Wp2DMQK/NmjVrrI0bN1p/+ctfrJ07d1p33HGH5fV6rVdeeSVWp2C722+/3UpJSbGampqsgwcPhtonn3wS6uPG35czuS5u+H3B6SEAtMH//d//WYsWLbJGjBhh+Xw+q7S01Pr4449Df9+3b58lyXr11Vcty7Ks9vZ2a968eVZqaqqVmJhoTZo0ybr77rutrq6uGJ2BfR555BHrggsusBISEqw5c+ZYb775Zuhv8+fPtxYvXhzW/7e//a317W9/20pISLAuuugi6/e///0gz3hwDOS63HnnnaG+6enp1ve+9z1r+/btMZi1OSceXfL1duI6LF682Jo/f/5J++Tm5loJCQnWxIkTrSeffHLQ5z0YBnptHnzwQevCCy+0kpKSrNTUVKuwsNDatGlTbCZvSKTrISnsO+DG35czuS5u+H3B6fFYlmUNWroRAAAAMcc9gAAAAC5DAAgAAOAyBIAAAAAuQwAIAADgMgSAAAAALkMACAAA4DIEgAAAAC5DAAgAAOAyBIAAAAAuQwAIAADgMgSAAAAALkMACAAA4DIEgAAAAC5DAAgAAOAyBIAAAAAuQwAIAADgMgSAAAAALvP/A9498C3KC69nAAAAAElFTkSuQmCC" alt="Code similarity matrix">
      </div>
      <div class="col">
        <h4 style="text-align: center;">Similarity Score Distribution</h4>
        <img src="data:image/png;base64, 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" alt="Code similarity histogram">
      </div>
    </div>
    <p style="text-align: center">
      <i>Note: a score of -1 in the similarity matrix indicates the comparison was skipped</i>
    </p>
    <p>
    Number of files tested: 3<br>
    Number of reference files: 3<br>
    Test files above display threshold: 2 (66.67%)<br><br>
    </p>

  <h2>Matched Code</h2>
  <table class="table table-striped table-sm">
  <tbody class="table-light">
  
  <tr>
  <td style="text-align: center;">
  <p>
    Test file: <i>hw2/puzzle.py</i> (<b>56.21%</b>)<br>
    Reference file: <i>hw2/reference/driver_3.py</i> (<b>34.99%</b>)<br>
    Token overlap: 561<br><br>
    <button class="btn btn-secondary" type="button" data-bs-toggle="collapse" data-bs-target="#collapse-1" aria-expanded="false" aria-controls="collapse-1">
      View matched code
    </button>
  </p>
  <div class="collapse" id="collapse-1">
    <div class="card card-body">
      <div class="row">
        <div class="col" style="max-width: 600px">
          <pre><code>import sys
from itertools import permutations
from copy import deepcopy
from queue import *

sudokuAssign = None
sudokuDomain = None
constrainList = None
sudokuConstraint = None




def AC3(sudokuAssign, sudokuDomain, constraintList):
    global sudokuConstraint
    q = <span class='highlight-red'>Queue()

    for c in constraintList:
        q.put(c)

    while not q.empty():
        temp </span>= q.get()
        Xi = temp[0]
        Xj = temp[1]
        
        <span class='highlight-red'>flag = False
        for x in sudokuDomain[Xi]:
            if not any(y != x for y in sudokuDomain[Xj]):
                sudokuDomain[Xi].remove(x)
                flag = True

        </span>if flag<span class='highlight-red'>:
            if not sudokuDomain[Xi]:
                return (False, sudokuAssign, sudokuDomain)
                
            </span>neighbours = [Xk for Xi, Xk in sudokuConstraint[Xi]]
            for Xk in neighbours:

                q.put((Xk,Xi))

    <span class='highlight-red'>for key,value in sudokuDomain.items():
        if len(value) == 1:
            sudokuAssign[key] = value[0]

    return </span>(True, sudokuAssign, sudokuDomain)

    
    
<span class='highlight-red'>def createSudokuCsp():
    global sudokuConstraint
    
 
    domain = [1,2,3,4,5,6,7,8,9]
    
    sudokuBoard = [[&#39;A1&#39;, &#39;A2&#39;, &#39;A3&#39;, &#39;A4&#39;, &#39;A5&#39;, &#39;A6&#39;, &#39;A7&#39;, &#39;A8&#39;, &#39;A9&#39;],
                   [&#39;B1&#39;, &#39;B2&#39;, &#39;B3&#39;, &#39;B4&#39;, &#39;B5&#39;, &#39;B6&#39;</span>, &#39;B7&#39;, &#39;B8&#39;, &#39;B9&#39;],
                   [&#39;C1&#39;, &#39;C2&#39;, &#39;C3&#39;, &#39;C4&#39;, &#39;C5&#39;, &#39;C6&#39;, &#39;C7&#39;, &#39;C8&#39;, &#39;C9&#39;],
                   [&#39;D1&#39;, &#39;D2&#39;, &#39;D3&#39;, &#39;D4&#39;, &#39;D5&#39;, &#39;D6&#39;, &#39;D7&#39;, &#39;D8&#39;, &#39;D9&#39;],
                   [&#39;E1&#39;, &#39;E2&#39;, &#39;E3&#39;, &#39;E4&#39;, &#39;E5&#39;, &#39;E6&#39;, &#39;E7&#39;, &#39;E8&#39;, &#39;E9&#39;],
                   [&#39;F1&#39;, &#39;F2&#39;, &#39;F3&#39;, &#39;F4&#39;, &#39;F5&#39;, &#39;F6&#39;, &#39;F7&#39;, &#39;F8&#39;, &#39;F9&#39;],
                   [&#39;G1&#39;, &#39;G2&#39;, &#39;G3&#39;, &#39;G4&#39;, &#39;G5&#39;, &#39;G6&#39;, &#39;G7&#39;, &#39;G8&#39;, &#39;G9&#39;],
                   [&#39;H1&#39;, &#39;H2&#39;, &#39;H3&#39;, &#39;H4&#39;, &#39;H5&#39;, &#39;H6&#39;, &#39;H7&#39;, &#39;H8&#39;, &#39;H9&#39;],
                   [&#39;I1&#39;, &#39;I2&#39;, &#39;I3&#39;, <span class='highlight-red'>&#39;I4&#39;, &#39;I5&#39;, &#39;I6&#39;, &#39;I7&#39;, &#39;I8&#39;, &#39;I9&#39;]]
 
    sudokuDomain = {key:list(domain) for row in sudokuBoard for key in row}
    
    sudokuAssign = {key:0 for key in sudokuDomain}


    constraintList = []
    
    for row in sudokuBoard:       
        constraintList = constraintList + list(permutations(row,2))

    Transpose = list(map(list, zip(*sudokuBoard)))  #Transpose the
    
    for col in Transpose:       
        constraintList </span>+= list(<span class='highlight-red'>permutations(col, 2))
        
    #Constraints within each 3x3 square
    for row in [0,3,6]:
        for col in [0,3,6]:
            box = [</span>]
            for i in range(row, row+3):
                for j in range(col, col+3):
                    val = sudokuBoard[i][j]
                    box.append(val)

            constraintList += list(<span class='highlight-red'>permutations(box,2))

    constraintList = list(set(constraintList))
    
    sudokuConstraint = {key:list([]) for key in sudokuDomain} 

    for val in constraintList:
        sudokuConstraint[val[0]].append(val) 
    
    # print(constraintList)
    return sudokuAssign, sudokuDomain, constraintList

def main(sudokuStrStart</span>):
    temp = createSudokuCsp()
    sudokuAssign = temp[0]
    sudokuDomain = temp[1]
    constrainList = temp[2]

  


    index = -1
    letter_head = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;]
    number_head = [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;]
    for i in letter_head:
        for j in number_head:
            hash = i + j
            index += 1
            sudokuAssign[hash<span class='highlight-red'>] = int(sudokuStrStart[index])
            if int(sudokuStrStart[index]) != 0:
                sudokuDomain[</span>hash] = [int(sudokuStrStart[index])]
    
    sudukuAssignCopy = deepcopy(sudokuAssign)
    sudukuDomainCopy = deepcopy(sudokuDomain)
    constrainListCopy = deepcopy(constrainList)


 


    a , b, c= AC3(sudukuAssignCopy, sudukuDomainCopy,  constrainListCopy)
    print(c<span class='highlight-red'>)
   
if __name__ == &#34;__main__&#34;:
    #Input sudoku string
    start = sys.argv[1]
    main(start)




 </span></code></pre>
        </div>
        <div class="col" style="max-width: 600px">
          <pre><code># -*- coding: utf-8 -*-

import sys
import copy
import itertools
import queue
    
<span class='highlight-green'>def createSudokuCsp():
    global sudokuConstraint
    
    #Create domain values
    domain = [1,2,3,4,5,6,7,8,9]
    #Create sudoku board containing all the variables
    sudokuBoard = [[&#39;A1&#39;, &#39;A2&#39;, &#39;A3&#39;, &#39;A4&#39;, &#39;A5&#39;, &#39;A6&#39;, &#39;A7&#39;, &#39;A8&#39;, &#39;A9&#39;],
                   [&#39;B1&#39;, &#39;B2&#39;, &#39;B3&#39;, &#39;B4&#39;, &#39;B5&#39;, &#39;B6&#39;</span>, &#39;B7&#39;, &#39;B8&#39;, &#39;B9&#39;],
                   [&#39;C1&#39;, &#39;C2&#39;, &#39;C3&#39;, &#39;C4&#39;, &#39;C5&#39;, &#39;C6&#39;, &#39;C7&#39;, &#39;C8&#39;, &#39;C9&#39;],
                   [&#39;D1&#39;, &#39;D2&#39;, &#39;D3&#39;, &#39;D4&#39;, &#39;D5&#39;, &#39;D6&#39;, &#39;D7&#39;, &#39;D8&#39;, &#39;D9&#39;],
                   [&#39;E1&#39;, &#39;E2&#39;, &#39;E3&#39;, &#39;E4&#39;, &#39;E5&#39;, &#39;E6&#39;, &#39;E7&#39;, &#39;E8&#39;, &#39;E9&#39;],
                   [&#39;F1&#39;, &#39;F2&#39;, &#39;F3&#39;, &#39;F4&#39;, &#39;F5&#39;, &#39;F6&#39;, &#39;F7&#39;, &#39;F8&#39;, &#39;F9&#39;],
                   [&#39;G1&#39;, &#39;G2&#39;, &#39;G3&#39;, &#39;G4&#39;, &#39;G5&#39;, &#39;G6&#39;, &#39;G7&#39;, &#39;G8&#39;, &#39;G9&#39;],
                   [&#39;H1&#39;, &#39;H2&#39;, &#39;H3&#39;, &#39;H4&#39;, &#39;H5&#39;, &#39;H6&#39;, &#39;H7&#39;, &#39;H8&#39;, &#39;H9&#39;],
                   [&#39;I1&#39;, &#39;I2&#39;, &#39;I3&#39;, <span class='highlight-green'>&#39;I4&#39;, &#39;I5&#39;, &#39;I6&#39;, &#39;I7&#39;, &#39;I8&#39;, &#39;I9&#39;]]
    #Assign domain values for each variable
    sudokuDomain = {key:list(domain) for row in sudokuBoard for key in row}
    #Create a copy of sudoku dictionary to store value assignment for each variable   
    sudokuAssign = {key:0 for key in sudokuDomain}

    #Create constraints
    constraintList = []
    #Constraints along row
    for row in sudokuBoard:       
        constraintList = constraintList + list(itertools</span>.<span class='highlight-green'>permutations(row,2))
    #Constraints along column
    sudokuBoardT = list(map(list,zip(*sudokuBoard))) #Transpose the sudoku board 
    
    for col in sudokuBoardT:       
        constraintList </span>= constraintList + list(itertools.<span class='highlight-green'>permutations(col,2))
    #Constraints within each 3x3 square
    for row in [0,3,6]:
        for col in [0,3,6]:
            box = [</span>val for row in sudokuBoard[row:row+3] for val in row[col:col+3]]    
            constraintList = constraintList + list(itertools.<span class='highlight-green'>permutations(box,2))
    #Remove duplicate constraints
    constraintList = list(set(constraintList))
    #Create a dictionary to store constraints. Initialize constraints to empty lists.
    sudokuConstraint = {key:list([]) for key in sudokuDomain} 
    #Associate the constraints with their respective keys in a dictionary
    for val in constraintList:
        sudokuConstraint[val[0]].append(val)



    return sudokuAssign, sudokuDomain, constraintList

def selectUnassignedVariable(sudokuAssign</span>,sudokuDomain):
    #Minimum remaining values heuristic is used
    MRV = 100 #A randomly chosen number larger than domain size
    for row in &#39;ABCDEFGHI&#39;:
        for col in &#39;123456789&#39;:
            if sudokuAssign[row+col] == 0: #Consider only unassigned variables
                value = sudokuDomain[row+col]
                if len(value) &lt; MRV:
                    MRV = len(value)
                    chosenKey = row+col 
    return chosenKey 

def consistent(sudokuAssign, sudokuDomain, chosenKey, value):
    global sudokuConstraint
    
    constraintList = sudokuConstraint[chosenKey]
    for constraint in constraintList:
        if value == sudokuAssign[constraint[1]]:
            return False 
    return True

def inference(sudokuAssign, sudokuDomain, chosenKey, value):
    #This inference function implements forward checking

    global sudokuConstraint
    
    constraintList = sudokuConstraint[chosenKey]
    for constraint in constraintList:
        checkKey = constraint[1]
        if sudokuAssign[checkKey] == 0: #Perform forward checking only on unassigned variables
            if value in sudokuDomain[checkKey]:
                sudokuDomain[checkKey].remove(value)
            <span class='highlight-green'>if not sudokuDomain[checkKey]: #If domain is empty, i.e., no legal values remaining 
                return (False, sudokuAssign, sudokuDomain)
    </span>return (True, sudokuAssign, sudokuDomain)
    
def backtracksearch(sudokuAssign,sudokuDomain):  
    #Check if assignment is complete
    if all(value&gt;0 for key,value in sudokuAssign.items()):
        return (True, sudokuAssign, sudokuDomain)
    chosenKey = selectUnassignedVariable(sudokuAssign,sudokuDomain)
    for value in sudokuDomain[chosenKey]:
        if consistent(sudokuAssign, sudokuDomain, chosenKey, value):
            sudokuAssignNew = copy.deepcopy(sudokuAssign)
            sudokuDomainNew = copy.deepcopy(sudokuDomain)
            sudokuAssignNew[chosenKey] = value
            sudokuDomainNew[chosenKey] = [value]
            resultInference = inference(sudokuAssignNew, sudokuDomainNew, chosenKey, value)
            if resultInference[0] == True:
                resultBTS = backtracksearch(resultInference[1],resultInference[2])
                if resultBTS[0] == True:
                    return resultBTS
    return (False, sudokuAssign, sudokuDomain)

def makeAssign(sudokuAssign, sudokuDomain):
    <span class='highlight-green'>for key,value in sudokuDomain.items():
        if len(value) == 1:
            sudokuAssign[key] = value[0]
    return </span>sudokuAssign    

def getNeighbours(Xi):
    global sudokuConstraint
    neighbours = [Xk for Xi, Xk in sudokuConstraint[Xi]]
    return neighbours
    
def revise(sudokuDomain, Xi, Xj):
    <span class='highlight-green'>revised = False
    for x in sudokuDomain[Xi]:
        if not any(y!=x for y in sudokuDomain[Xj]):
            sudokuDomain[Xi].remove(x)
            revised = True
    </span>return revised

def AC3(sudokuAssign,sudokuDomain, constraintList):  
    q = queue.<span class='highlight-green'>Queue()
    for constraint in constraintList:
        q.put(constraint)
    while not q.empty():
        Xi</span>,Xj = q.get()
        if revise(sudokuDomain, Xi, Xj)<span class='highlight-green'>:
            if not sudokuDomain[Xi]:
                return (False, sudokuAssign</span>, sudokuDomain)
            for Xk in getNeighbours(Xi):
                q.put((Xk,Xi))
    sudokuAssign = makeAssign(sudokuAssign, sudokuDomain)
    return (True, sudokuAssign, sudokuDomain)

def visualizeBoard(sudokuAssign):
    #Prints a sudoku grid containing the assigned variables.
    #This function accepts a dictionary of the form:
    #sudokuAssign = {&#39;A1&#39;:1, &#39;A2&#39;:4, &#39;A3&#39;:8, &#39;A4&#39;:0, &#39;A5&#39;:0, &#39;A6&#39;:7, &#39;A7&#39;:5, &#39;A8&#39;:0, &#39;A9&#39;:3,
    #                &#39;B1&#39;:3, &#39;B2&#39;:0, &#39;B3&#39;:2, &#39;B4&#39;:0, &#39;B5&#39;:4, &#39;B6&#39;:0, &#39;B7&#39;:9, &#39;B8&#39;:0, &#39;B9&#39;:1,
    #                   :
    #                   :
    #                &#39;I1&#39;:2, &#39;I2&#39;:8, &#39;I3&#39;:4, &#39;I4&#39;:0, &#39;I5&#39;:6, &#39;I6&#39;:0, &#39;I7&#39;:0, &#39;I8&#39;:3, &#39;I9&#39;:9,}
    #&#39;0&#39; values indicate unassigned variables and will not be printed.                         

    s = &#34;&#34;
    line = &#34;-------------------------------------\n&#34;
    s += line
    for row in &#34;ABCDEFGHI&#34;:
        s += &#34;|&#34;
        for col in &#34;123456789&#34;:
            if sudokuAssign[row + col] != 0:
                s += (&#34;%3d&#34; % sudokuAssign[row + col]) + &#34;|&#34;
            else:
                s += (&#34;%3c&#34; % &#39; &#39;) + &#34;|&#34;
        s += &#34;\n&#34; + line
    
    # print(s)
           
def main(sudokuStrStart):
    #Initialize sudoku assignments, domain, and constraints
    sudokuAssign, sudokuDomain, constraintList = createSudokuCsp()
    
    #Load sudoku starting board
    index = -1
    for j in &#39;ABCDEFGHI&#39;:
        for i in &#39;123456789&#39;:
            key = j+i
            index = index + 1
            sudokuAssign[key<span class='highlight-green'>] = int(sudokuStrStart[index])
            if int(sudokuStrStart[index]) != 0:
                sudokuDomain[</span>key] = [int(sudokuStrStart[index])]
    
    print(&#39;Starting sudoku board&#39;)
    visualizeBoard(sudokuAssign)

    #Run AC3 algorithm first.             
    flag, sudokuAssignNew, sudokuDomainNew = AC3(copy.deepcopy(sudokuAssign),copy.deepcopy(sudokuDomain), copy.deepcopy(constraintList))

    # print(flag)
    # print(sudokuAssignNew)
    print(sudokuDomainNew)
    algoName = &#39;AC3&#39;
    #If the assignment is consistent after AC3, copy the assigned values into respective variables 
    if flag == True:
        sudokuAssign = sudokuAssignNew
        sudokuDomain = sudokuDomainNew
    if all(value&gt;0 for key,value in sudokuAssignNew.items()):
        pass #All variables have been successfully assigned by AC3 algorithm 
    else: #If AC3 fails, use the reduced domain space and BTS to solve the puzzle
        print(&#39;Mid sudoku board&#39;)
        visualizeBoard(sudokuAssign) 
        flag, sudokuAssign, sudokuDomain = backtracksearch(copy.deepcopy(sudokuAssign),copy.deepcopy(sudokuDomain))
        algoName = &#39;BTS&#39;
    
    print(&#39;Completed sudoku board&#39;)
    visualizeBoard(sudokuAssign) 
    
    #Create the sudoku string from the sudoku assignment dictionary
    sudokuStrFinish = &#39;&#39;
    index = -1
    for j in &#39;ABCDEFGHI&#39;:
        for i in &#39;123456789&#39;:
            key = j+i
            sudokuStrFinish = sudokuStrFinish + str(sudokuAssign[key])

    #Write output to file
    file = open(&#34;output.txt&#34;,&#34;w&#34;)
    file.write(&#39;{} {}&#39;.format(sudokuStrFinish,algoName))
    file.close(<span class='highlight-green'>)
    
if __name__ == &#34;__main__&#34;:
    #Input sudoku string
    sudokuStrStart = sys.argv[1]
#    sudokuStrStart = &#39;000000000302540000050301070000000004409006005023054790000000050700810000080060009&#39;
    #Call main function
    main(sudokuStrStart)</span>
</code></pre>
        </div>
      </div>
    </div>
  </div>
  </td>
  </tr>
  
  </tbody>
  </table>
</div>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-kQtW33rZJAHjgefvhyyzcGF3C5TFyBQBA13V1RKPf4uH+bwyzQxZ6CmMZHmNBEfJ" crossorigin="anonymous"></script>
</body>